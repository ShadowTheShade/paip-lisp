#+title Emacs Configuration
#+PROPERTY: header-args:lisp :tangle ./paip-lisp.lisp :mkdir

* Org Mode Configuration
#+begin_src emacs-lisp
    (defun efs/org-babel-tangle-paip-lisp ()
        (when (string-equal (buffer-file-name)
                            (expand-file-name "~/Coding/CLISP/paip-lisp/org-paip-lisp.org"))
          ;; Dynamic scoping
          (let ((org-confirm-babel-evaluate-nil))
            (org-babel-tangle))))

    (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'efs/org-babel-tangle-paip-lisp)))

    (setq org-src-tab-acts-natively t)

  (modify-syntax-entry ?< ".")
  (modify-syntax-entry ?> ".")
#+end_src

* Chapter 1

#+begin_src lisp :tangle ./chapter1.lisp
      (setf p '(John Q Small))

      (setf names '((John Q Public) (Malcolm X)
                         (Admiral Grace Murray Hopper) (Spot)
                         (Aristotle) (A A Milne) (Z Z Top)
                         (Sir Larry Olivier) (Miss Scarlet)))

      (defun last-name (name)
        "Select the last name from a name represented in a list"
        (first (last name)))

      (defparameter *titles*
        '(Mr Mrs Miss Ms Sir Madam Dr Admiral Major General)
        "A list of titles that can appear at the start of a name")

      (defun first-name (name)
        "Select the first name from a name represented as a list"
        (if (member (first name) *titles*)
            (first-name (rest name))
            (first name)))

      (mapcar #'last-name names)
      (mapcar #'first-name names)

      (defparameter *titles*
        '(Mr Mrs Miss Ms Sir Madam Dr Admiral Major General)
        "A list of titles that can appear at the start of a name")

      ;; Trace function
      (trace first-name)

      (first-name '(Madam Major General Paula Jones))

      (untrace first-name)

                                              ; Higher Order Functions

      (defun mappend (fn the-list)
        "Apply fn to each element of the list and append the result to each element"
        (apply #'append (mapcar fn the-list)))

      (defun self-and-double (x) (list x (+ x x)))

      (self-and-double 3)

      (mapcar #'self-and-double '(1 10 300))

      (mappend #'self-and-double '(1 10 300))

      (defun number-and-negation (x)
        "If x is a number, return a list of x and -x"
        (if (numberp x)
            (list x (- x)
                  nil)))

      (defun numbers-and-negations (input)
        "Given a list, return only the numbers and their negations"
        (mappend #'number-and-negation input))

      ;; Updated mappend
      (defun mappend (fn the-list)
        "Apply fn to each element of list and append the results"
        (if (null the-list)
            nil
            (append (funcall fn (first the-list))
                    (mappend fn (rest the-list)))))

      ;; Anonymous functions

      ((lambda (x) (+ x 2)) 4)

      (funcall #'(lambda (x) (+ x 2)) 4)

      ;; Examples
      (mapcar #'(lambda (x) (+ x x)) '(1 2 3 4 5))

      (mappend #'(lambda (l) (list l (reverse l))) '((1 2 3) (a b c)))

      ;; 1.8 Other Data Types

      "a string"

      (length "a string")

      (length "")

      ;; 1.9 Lisp Evaluation Rule
      'John (quote John) ;; Equivalent

      ;; 1.10 Features and Uniqueness of Lisp

      (defun atomprint (exp &optional (depth 0))
        "Print each atom in exp, along with its depth of nesting."
        (if (atom exp)
            (format t "~&ATOM: ~a, DEPTH ~d" exp depth)
            (dolist (element exp)
              (atomprint element (+ depth 1)))))

      (atomprint p)

      ;; 1.11 Exercises

      ;; Exercise 1.1

      (defparameter *end-titles*
        '(MD Jr. Sr.))

      (defun last-name (name)
        "Prints out the last name of a name list, filtering out end titles"
        (if (or (not (rest name)) (member (second name) *end-titles*))
            (first name)
            (last-name (rest name))))

      (setq jimmy '(Jimmy Smalls Jr. Sr.))
      (setq john '(John Waters))

      (last-name jimmy)
      (last-name john)

      ;; Exercise 1.2

      (defun power (base exp)
        "Returns a number base raised to the exp integer power"
        (if (>= exp 1)
            (* base (power base (- exp 1)))
            1))

      (power 3 2)
      (power 6 2)
      (power 5 3)

      ;; Exercise 1.3

      (defun count-atoms (exp &optional (total 0))
        "Counts the atoms in an expression"
        (if (or (rest exp) (first exp))
            (count-atoms (rest exp) (+ total 1))
            total))

    (count-atoms '(1 2 a b))
    (count-atoms '((1 "a") () (a)))

    ;; Exercise 1.4
    (defun count-anywhere (exp tree)
      "Counts the number of times an expression shows up in another"
      (cond ((eql exp tree) 1)
            ((atom tree) 0)
            (t (+ (count-anywhere exp (first tree))
                  (count-anywhere exp (rest tree))))))

    (count-anywhere 'a '(a (a b) ((b a) a)))

    ;; Exercise 1.5
    (defun dot-product (v1 v2)
      "Takes the dot product of two vectors"
      (if (first v1)
          (+
          (* (first v1) (first v2))
          (dot-product (rest v1) (rest v2)))
          0))

    (dot-product '(10 20) '(3 4))


#+end_src

** Features of Common Lisp
- Dynamic Typing
- First-Class Functions
  - Functions can be made at runtime
- Uniform Syntax (parentheses)
- Interactive Environment
  - Symbol table is first-class
  - Can define and test while writing, before compiling
- Extensibility

* Chapter 2
#+begin_src lisp :tangle ./chapter2.lisp
  ;; Chapter 2

  ;; 2.2 A Straightforward Solution

  ;; Random selection from a list

  (defun random-elt (choices)
    "Choose a random element belonging to a list."
    (elt choices (random (length choices))))

  (defun one-of (set)
    "Pick one element from set, and make a list of it."
    (list (random-elt set)))

  ;; Basic sentence creation

  (defun sentence ()    (append (noun-phrase) (verb-phrase)))
  (defun noun-phrase () (append (Article) (Noun)))
  (defun verb-phrase () (append (Verb) (noun-phrase)))
  (defun Article ()     (one-of '(the a)))
  (defun Noun ()        (one-of '(man ball woman table)))
  (defun Verb ()        (one-of '(hit took saw liked)))

  ;; Adding multiple adjectives and preposition phrases

  (defun Adj* ()
    (if (= (random 2) 0)
        nil
        (append (Adj) (Adj*))))

  (defun noun-phrase () (append (Article) (Adj*) (Noun) (PP*)))
  (defun PP () (append (Prep) (noun-phrase)))
  (defun Adj () (one-of '(big little blue green adiabatic)))
  (defun Prep () (one-of '(to in by with on)))



  (defun PP* ()
    (if (= (random 2) 0)
        nil
        (append (PP) (PP*))))

  ;; 2.3 A Rule-Based Solution

  (defparameter *simple-grammar*
    '((sentence -> (noun-phrase verb-phrase))
      (noun-phrase -> (Article Noun))
      (verb-phrase -> (Verb noun-phrase))
      (Article -> the a)
      (Noun -> man ball woman table)
      (Verb -> hit took saw liked))
    "Simple grammar for english.")

  (defvar *grammar* *simple-grammar*
    "The grammar used by generate. Initially simple grammar.")

  (assoc 'sentence *grammar*)

  (sentence)

  (defun rule-lhs (rule)
    "The left-had side of a rule."
    (first rule))

  (defun rule-rhs (rule)
    "The right hand side of a rule"
    (rest (rest rule)))

  (defun rewrites (category)
    "Returns a list of the possible rewrites for this category."
    (rule-rhs (assoc category *grammar*)))

  (defun generate (phrase)
    "Generate a random sentence or phrase."
    (cond ((listp phrase)
           (mappend #'generate phrase))
          ((rewrites phrase)
           (generate (random-elt (rewrites phrase))))
          (t (list phrase))))

  ;; if version

  (defun generate (phrase)
    "Generate a random sentence or a phrase"
    (if (listp phrase)
        (mappend #'generate phrase)
        (let ((val (rewrites phrase)))
          (if val
              (generate (random-elt val))
              (list phrase)))))

  ;; Exercise 2.1

  (defun generate (phrase)
    "Generates a random sentence or phrase using cond, but only uses rewrites once"
    (let ((choices (rewrites phrase)))
      (cond ((listp phrase)
             (mappend #'generate phrase))
            (choices
             (generate (random-elt choices)))
            (t (list phrase)))))

  ;; Exercise 2.2

  (defun generate (phrase)
    "Generates a random sentence or phrase by explicitly checking what is input"
    (if (listp phrase)
        (mappend #'generate phrase)
        (cond ((assoc phrase *grammar*)
               (generate (random-elt (rewrites phrase))))
              (t (list phrase)))))

  (defparameter *bigger-grammar*
    '((sentence -> (noun-phrase verb-phrase))
      (noun-phrase -> (Article Adj* Noun PP*) (Name) (Pronoun))
      (verb-phrase -> (Verb noun-phrase PP*))
      (PP* -> () (PP PP*))
      (Adj* -> () (Adj Adj*))
      (PP -> (Prep noun-phrase))
      (Prep -> to in by with on)
      (Adj -> big little blue yellow tall)
      (Article -> the a one)
      (Name -> Pat Dalia Anthony Biagio)
      (Noun -> man ball woman table)
      (Verb -> hit saw took liked)
      (Pronoun -> he she it these those that)))

  (setf *grammar* *bigger-grammar*)

  ;; 2.6 Reusing Data for Several Programs

  (defun generate-tree (phrase)
    "Generates a random sentende or phrase, but with a tree description"
    (cond ((listp phrase)
           (mapcar #'generate-tree phrase))
          ((rewrites phrase)
           (cons phrase
                 (generate-tree (random-elt (rewrites phrase)))))
          (t (list phrase))))


  (defun combine-all (xlist ylist)
    "Returns a list of lists formed by appending a y to an x. (All permutations)"
    (mappend #'(lambda (y)
                 (mapcar #'(lambda (x) (append x y)) xlist))
             ylist))

  (defun generate-all (phrase)
    "Generates a list of all possible expansions of the desired phrase"
    (cond ((null phrase) (list nil))
          ((listp phrase)
           (combine-all (generate-all (first phrase))
                        (generate-all (rest phrase))))
          ((rewrites phrase)
           (mappend #'generate-all (rewrites phrase)))
          (t (list (list phrase)))))

  ;; 2.7 Exercises

  ;; Exercise 2.3

  (defparameter *grammatico-italiano-simplici*
    '((frase -> (frase-nome frase-verbo))
      (frase-nome -> (Clausola Nome))
      (frase-verbo -> (Verbo frase-nome))
      (Clausola -> la il le)
      (Verbo -> frappa saluta vedi)
      (Nome -> personna bambino genti)))

  ;; Exercise 2.4

  (defun cross-product (fn xvec yvec)
    "Perform the cross product based on a function on two vectors."
    (mappend #'(lambda (y)
                 (mapcar #'(lambda (x) (funcall fn x y)) xvec))
             yvec))


  (defun combine-all-cross (xlist ylist)
    "Returns a list of the cartesian products betweeen xlist and ylist"
    (cross-product #'list xlist ylist))
#+end_src

* Chapter 3
** Chapter 3
#+begin_src lisp :tangle ./chapter3.lisp
  ;; Chapter 3 : Overview of Special Forms and Functions

  ;; 3.1 A Guide to Lisp Style

  ;; Special Forms

  (setq body 1)

  ;; Functions and macros
  (defun function-name (parameters) "documentation" body)
  (defmacro macro-name (parameters) "documentation" body)

  ;; Variables, parameters, constants
  (setq initial-value 1)
  (setq value 1)

  (defvar variable-name initial-value "documentation")
  (defparameter parameter-name value "documentation")
  (defconstant constant-name value "documentation")

  variable-name

  ;; Structs

  (defstruct name
    first
    (middle nil)
    last)

  ;; defstruct automatically defines:
  ;; constructor function make-name
  ;; recognizer predicate name-p
  ;; accessor functions: name-first, name-middle, name-last
  ;; middle is nil by default

  (setf b (make-name :first 'Anthony :last 'Gagliano))

  (name-first b)
  (name-middle b)
  (name-last b)
  (name-p b)
  (name-p 'Anthony)
  ;; Structs are arrays in memory, index 0 is the type, index 1 is first.. etc

  ;; Conditionals

  (if nil
      t)

  (setq n 200)

  ;; Single condition

  (when (> n 100)
    (princ "N is large"))

  ;; Many condition

  (defun grade-scheme (grade)
    "Determine the letter grade for a given numeric grade"
    (cond ((< grade 60) 'F)
          ((< grade 70) 'D)
          ((< grade 75) 'C)
          ((< grade 85) 'B)
          ((< grade 95) 'A)
          (t 'A+)))

  ;; Setf
  (setf li '(a b c))

  (setf (rest li) nil)

  ;; let

  ;; x and y are bound locally

  (setq x 5)
  (setq y 12)

  (let ((x 40)
        (y (+ 1 1)))
    (+ x y))

  (+ x y)

  ;; Anonymous functions

  ((lambda (x y)
     (+ x y))
   40
   (+ 1 1))

  ;; let* allows you to use variables already defined in the definition list to define new ones
  (let* ((x 6)
         (y (* x x)))
    (+ x y))

  ;; Exercise 3.1

  ((lambda (x)
     ((lambda (y)
        (+ x y)) (* x x))) 6)

  (defvar alist '(a b c))
  (push 'z alist)
  (pop alist)

  ;; Incrementing

  (defvar inc 1)
  (incf inc)
  (decf inc)

  ;; Infinite Integer Generatior

  (let ((x 0))
    (defun int-up ()
      "Every time this function is called, it increases by 1"
      (incf x 1))
    (defun int-down ()
      "Every time this function is called, it is decreased by 1"
      (decf x 1)))

  (int-up)
  (int-down)

  (if 0
      t
      0)

  (repeat #'int-up 10)

  ;; Example using players and scores in a game
  (defstruct player
    (score 0)
    (wins 0))

  (defun determine-winner (players)
    "Increment the WINS for the player with the highest score"
    (incf (player-wins (first (sort players #'>
                                    :key #'player-score)))))

  (defun determine-winner (players)
    "Increment the WINS for the player with the highest score"
    (let ((temp (first (sort players #'> :key #'player-score))))
    (setf (player-wins temp) (+ (player-wins temp) 1))))

  ;; Repetition special forms and functions

  (defun length1 (list)
    "Increment len for every element in the list starting from 0"
    (let ((len 0))
      (dolist (element list)
        (incf len))
      len))

  (defun length2 (list)
    "Applies an increment function to every element of the list"
    (let ((len 0))
      (mapc #'(lambda (element)
                (incf len))
            list)
      len))

  ;; mapc is like mapcar but mapcar returns the values in a list

  (defun len3 (list)
    "Increment len by one and shorten list by one every loop until l is null and return len"
    (do ((len 0 (+ len 1))
         (l list (rest l)))
        ((null l) len)))

  (len3 '(a b c d))


  ;; loop specific language

  (defun len4 (list)
    (loop for element in list
          count t))

  (defun length5 (list)
    (loop for element in list
          summing 1))

  (defun length6 (list)
    (loop with len = 0
          until (null list)
          for element = (pop list)
          do (incf len)
          finally (return len)))

  (defun true (x) t)

  (defun length7 (list)
    (count-if #'true list))

  (defun length8 (list)
    (if (null list)
        0
        (+ 1 (position-if #'true list :from-end t))))

  ;;Function examples
  (mapcar #'- '(1 2 3))
  (mapcar #'+ '(1 2) '(10 20))
  (mapcar #'+ '(1 2) '(10 20) '(100 200))

  (remove 1 '(1 2 3 2 1 0 -1))
  (remove 1 '(1 2 3 2 1 0 -1) :key #'abs)
  (remove 1 '(1 2 3 2 1 0 -1) :test #'<)
  (remove 1 '(1 2 3 2 1 0 -1) :start 4)

  (remove-if #'oddp '(1 2 3 2 1 0 -1))
  (remove-if-not #'oddp '(1 2 3 2 1 0 -1))
  (find-if #'evenp '(1 2 3 2 1 0 -1))

  ;; Other examples
  (setq x '(a b c))
  (setq y '(1 2 3))

  (every #'oddp y) ; test if every element satisfies a predicate
  (some #'oddp y) ; test is some elements satisfy a predicate
  (mapcar #'- y) ; apply function to each value and return result
  (mapc #'print y) ; apply function to each value

  (member 2 y)
  (count 'b x)
  (delete 1 y) ; omit matching elements
  (find 2 y) ; first element that matches
  (position 'a x) ; index of the element in the sequence
  (reduce #'+ y) ; fold the list applying function to successive elements
  (remove 2 y) ; like delete but makes a copy
  (substitute 4 2 y) ; replace every matching element with the new one

  ;; Repetition through recursion
  (defun length9 (list)
    (if (null list)
        0
        (+ 1 (length9 (rest list)))))

  ;; Helper function to avoid bulding a stack frame -> tail-end recursion
  (defun length10-aux (sublist len-so-far)
    (if (null sublist)
        len-so-far
        (len10-aux (rest sublist) (+ 1 len-so-far))))

  (defun length10 (list)
    (length10-aux list 0))

  ;; Combining them
  (defun length11 (list &optional (len-so-far 0))
    (if (null list)
        len-so-far
        (length11 (rest list) (+ 1 len-so-far))))

  ;; Using a local function

  (defun length12 (the-list)
    (labels
        ((length13 (list len-so-far)
           (if (null list)
               len-so-far
               (length13 (rest list) (+ 1 len-so-far)))))
      (length13 the-list 0)))

  ;; Other special forms

  ;; progn evaluates a sequence of forms and returns the last one
  (progn (setf x 0) (setf x (+ x 1)) x)

  ;; return to break out of 'blocks'
  (defun product (numbers)
    "Multiply all the numbers together to compute their product"
    (let ((prod 1))
      (dolist (n numbers prod)
        (if (= n 0)
            (RETURN 0)
            (setf prod (* n prod))))))

 
#+end_src
** Macros
- Steps to defining a macro
  1) Decide if the macro is necessary
  2) Write down the syntax of the macro
  3) Figure out what the macro should expand into
  4) Use defmacro to implement the syntax/expansion correspondence
- Example : while
  1) Example
  2) (while test body...)
  3) loop
        unless test (return nil)
        body
  4) 
#+begin_src lisp :tangle ./chapter3.lisp

  ;; Macros

  ;; Try to define only when absolutely necessary and make the easy to understand

  (defmacro while (test &rest body)
    "Repeat body while test is true"
    (list* 'loop
           (list 'unless test '(return nil))
           body))

  ;; Macro expand takes an example and shows you what the macro does

  (macroexpand-1 '(while (< 1 10)
                   (print (* i i))
                   (setf i (+ i 1))))

  (defmacro while (test &rest body)
    "Repeat body while test is true"
    (let ((code '(loop (unless test (return nil)) . body)))
      (subst test 'test (subst body 'body code))))

  ;; Backquote, comma and comma@
  ;; ` indicates mostly literal expression, with possiblity of evaluation
  ;; anything marked by , is evaluated and inserted into the structure
  ;; anything marked by ,@ must evaluate to a list that is spliced into the structure

  (defmacro while (test &rest body)
    "Repeat body while test is true"
    `(loop (unless ,test (return nil))
           ,@body))

  ;; Examples
  (setf test1 '(a test))

  `(this is ,test1)
  `(this is ,@test1)
  `(this is . ,test1)
  `(this is ,@test1 -- this is only ,@test1)


#+end_src 
** Functions on lists
#+begin_src lisp :tangle ./chapter3.lisp
  ;; 3.3 Functions on Lists
  (setq x '(a b c))
    (setq y '(1 2 3))

    ;; Key functions
    (first x)
    (second x)
    (third x)
    (nth 0 x)
    (rest x)
    (car x)
    (cdr x)
    (last x)
    (cdr x)
    (last x)
    (length x)
    (cons 0 y)
    (append x y)
    (list x y)
    (list* 1 2 x)
    (null nil)
    (null x)
    ;; T for any list including nil
    (listp x)
    (listp 3)
    (listp nil)
    ;;True for non-nil list
    (consp x)
    (consp nil)

    (equal x x)
    (equal x y)
    (sort y #'>)
    ;; Subsequence
    (subseq x 1 2)

    ;; Exercise 3.2
    ;; The function cons can be seen as a special case of one of the other functions listed, which one?
    ;; Special case of the list* function, where it takes only 1 item to insert and one list

    ;; Exercise 3.3
    ;; Write a function that will print an expression in dotted pair notation. Use built-in function princ to print each component of the expression

    (defun pr-rest (x)
      (princ " . ")
      (dprint x))

    (defun dprint (dp)
      "Prints the values of a dotted pair expression in dotted pair notation"
      (cond ((atom x) (princ x))
            (t (princ "(")
               (dprint (first x))
               (pr-rest (rest x))
               (princ ")")
               x)))

    ;; Exercise 3.4
    ;; Write a function that, like print, will print an expression in dotted pair notation when necessary but will use normal list notation when possible
    (defun pr-rest (x)
      (cond ((null x))
            ((atom x) (princ " . ") (princ x))
            (t (princ " ") (dprint (first x)) (pr-rest (rest x)))))
#+end_src
** Functions on Sequences
Indexing
   - (nth n list)
   - (elt sequence n)
   - (aref arrray n)
   - (char string n)
   - (bit bit-vector n)
   - (sbit simple-bit-vector n)
   - (svref simple-vector n)
** Functions for Maintaining Tables
#+begin_src lisp :tangle ./chapter3.lisp
  ;; 3.6 Functions on Maintaining tables
  (setf state-table '((AL . Alabama) (AK . Alaska) (AZ . Arizona) (AR . Arkansas)))

  (assoc 'AK state-table)
  (cdr (assoc 'AK state-table))
  (assoc 'TX state-table)

  ;; Search by value rarther than key
  (rassoc 'Arizona state-table)
  (car (rassoc 'Arizona state-table))

  ;; Hash tables
  (setf table (make-hash-table))

  (setf (gethash 'AL table) 'Alabama)
  (setf (gethash 'AK table) 'Alaska)
  (setf (gethash 'AZ table) 'Arizona)
  (setf (gethash 'AR table) 'Arkansas)

  (gethash 'AK table)
  (gethash 'TX table)

  ;; Remove key/value pairs with remhash
  ;; Clear all pairs with clrhash
  ;; Map over the key/value pair with maphash

  ;; Property lists
  ;; a-list: ((key1 . val1) (key2 . val2) ... (keyn . valn))
  ;; p-list: (key1 val1 key2 val2 ... keyn valn)

  ;; Property Tables

  ;; Building a property table using setf
  (setf (get 'AL 'state) 'Alabama)
  (setf (get 'AK 'state) 'Alaska)
  (setf (get 'AZ 'state) 'Arizona)
  (setf (get 'AR 'state) 'Arkansas)

  (get 'AK 'state)
  (get 'TX 'state)
  ;; No corresponding rassoc for property tables. A separate table would have to be created

  (setf (symbol-plist 'state-table) '(AL Alabama AK Alaska AZ Arizona AR Arkansas))
  (get 'state-table 'AL)
  (get 'state-table 'Alaska)
#+end_src
** Functions on Trees
#+begin_src lisp :tangle ./chapter3.lisp
  ;; 3.7 Functions on Trees
  (setf tree '((a b) ((c)) (d e)))
    (tree-equal tree (copy-tree tree))

    (defun true (&rest ignore) t) ;; Ignores the leaves, which are the only things with 'values' in this example

    (defun same-shape-tree (a b)
      "Are two trees the same except for the leaves?"
      (tree-equal a b :test #'true))

    (same-shape-tree tree '((1 2) ((3)) (4 5)))
    (same-shape-tree tree '((1 2) (3) (4 5)))

    ;; Substituting expressions in a tree

    (subst 'new 'old '(old ((very old))))
    (sublis '((old . new)) '(old ((very old))))
    (subst 'new 'old 'old)

    (defun english->french (words)
      (sublis '((are . sommes) (book . libre) (house . maison) (friend . ami) (hello . bonjour) (bread . pain) (yellow . jaune) (you . tu) (my . mon) (your . ton) (eat . mange))
              words))

    (english->french '(hello my friend - eat your bread))

#+end_src
** Functions on Numbers
#+begin_src lisp :tangle ./chapter3.lisp
  ;; Functions on Numbers
  (+ 4 2)
  (- 4 2)
  (* 4 2)
  (/ 4 2)
  (> 100 99)
  (= 100 100)
  (< 99 100)
  (random 100)
  (expt 4 2)
  (sin pi)
  (asin 0)
  (min 2 3 4)
  (abs -3)
  (sqrt 4)
  (round 4.1)
  (rem 11 5)
  (mod 11 5)
#+end_src
** Functions on Sets
#+begin_src lisp :tangle ./chapter3.lisp
  ;; 3.9 Functions on Sets
  ;; Use of a list to represent a set

    (setf r '(a b c d))
    (setf s '(c d e))

    ;; Useful functions
    (intersection r s) ;; Common elements
    (union r s) ;; Collection of all elements
    (set-difference r s) ;; Whatever isn't in the intersecton belonging the sets
    (member 'd r) ;; Check if element is a member of the set
    (subsetp s r) ;; Returns true if s is a subset of r
    (adjoin 'b s) ;; Adds to the set if not already present
    (adjoin 'c s)

#+end_src
** Destructive Functions
#+begin_src lisp :tangle ./chapter3.lisp
  ;; 3.10 Destructive Functions 

  (setf x '(a b c))
  (setf y '(1 2 3))
  (append x y)

  ;; Function that changes the value of the inputs
  (nconc x y)
  x
  y

  ;; Exercise 3.5
  ;; Write a program that will play the role of the guesser in the game Twenty Questions. The user of the program will have in mind any type of thing. The program will ask questions of the user, which must be answered yes or no, or "it" when the program has guessed it. If the program runs out of guesses, it gives up and asks the user what "it" was. At first the program will not play well, but each time it plays, it will remember the user's replies and use them for subsequent guesses.

  (defstruct pokemon
    name
    primary-type
    (secondary-type nil)
    (stage 'basic)
    pokedex-no.)

  ;; List of first-generation pokemon
  (setq pokedex
        '((bulbasaur ivysaur venusaur)
          (charmander charmeleon charizard)
          (squirtle wortortle blastoise)
          (caterpie metapod butterfree)
          (weedle kakuna beedrill)
          (pidgey pidgeotto pidgeot)
          (rattata raticate)
          (spearow fearow)
          (ekans arbok)
          (pikachu raichu)
          (sandshrew sandslash)
          (nidoran-f nidorina nidoqueen)
          (nidoran-m nidorino nidoking)
          (clefairy clefable)
          (vulpix ninetales)
          (jigglypuff wigglytuff)
          (zubat golbat)
          (oddish gloom vileplume)
          (paras parasect)
          (venonat venomoth)
          (diglett dugtrio)
          (meowth persian)
          (psyduck golduck)
          (mankey primeape)
          (poliwag poliwhirl poliwrath)
          (abra kadabra alakazam)
          (machop machoke machamp)
          (bellsprout weepinbell victreebel)
          (tentacool tentacruel)
          (geodude graveler golem)
          (ponyta rapidash)
          (slowpoke slowbro)
          (magnemite magneton)
          (farfetch'd)
          (doduo dodrio)
          (seel dewgong)
          (grimer muk)
          (shellder cloyster)
          (ghastly haunter gengar)
          (onix)
          (drowzee hypno)
          (krabby kingler)
          (voltorb electrode)
          (exeggcute exeggutor)
          (cubone marowak)
          (hitmonlee)
          (hitmonchan)
          (lickitung)
          (koffing weezing)
          (rhyhorn rhydon)
          (chansey)
          (tangela)
          (kangaskhan)
          (horsea seadra)
          (goldeen seaking)
          (staryu starmie)
          (mr.mime)
          (scyther)
          (jynx)
          (electabuzz)
          (magmar)
          (pinsir)
          (tauros)
          (magikarp gyarados)
          (lapras)
          (ditto)
          (eevee vaporeon jolteon flareon)
          (porygon)
          (omanyte omastar)
          (kabuto kabutops)
          (snorlax)
          (articuno)
          (zapdos)
          (moltres)
          (dragonair dragonite)
          (mewtwo)
          (mew)))



  (setq bulbasaur (make-pokemon :name 'bulbasaur :primary-type 'electric :pokedex-no. 1))



  (defvar *pokedex*
    '((make)
      )
    )

    (defstruct type )

  (setq colours '(red yellow orange green blue violet black white brown))

  (setq shape '(circle triangle square box ball))

  (setq size '(tiny small medium large enormous))

  (setq clues
        '((make-guess :type 'Vegetable) ))


  (defun associate (type clue)
    )


#+end_src
** Input and Output
#+begin_src lisp :tangle ./chapter3.lisp
  ;; 3.12 Input/Output

  ;; Create file test.txt and write to it

  (with-open-file (stream "test.txt" :direction :output)
    (print '(hello there) stream)
    (princ 'goodbye stream))

  ;; Read from the same file
  (with-open-file (stream "test.txt" :direction :input)
    (list (read stream) (read-char stream) (read stream)
          (read stream nil 'eof)))

  ;; terpri stands for "terminate print line" and it skips to the next line
  ;; fresh-line does the same unless it determines it is already at the front of a line

  (format t "hello world")

  (format t "~&~a plus ~s is ~f" "two" "two" 4)
  ;; ~& moves to a fresh line
  ;; ~a prints the next argument as princ would
  ;; ~s prints the next argument as prin1 would
  ;; ~f prints a number in floating point format

  (let ((numbers '(1 2 3 4 5)))
    (format t "~&~{~r~^ plus ~} is ~@r"
            numbers (apply #'+ numbers)))
  ;; ~r prints the next argument, which should be a number, in english
  ;; ~@r prints the next argument, which should be a number, in roman numerals
  ;; ~{...~} takes the next argument, which should be a list and formats each of the contents according to what is between the braces
  ;; ~^ exits from the enclosing loop if there are no more arguments remaining
#+end_src
** Debugging Tools
Strategies for debugging
   1. Run code with print statements
   2. Use a debugging program
   3. Add annotations that are not a part of the program but add the effect of automatically altering the running program
#+begin_src lisp :tangle ./chapter3.lisp
  ;; 3.13 Debugging Tools
  ;; We have already seen trace and untrace

  ;; step can be used to halt execution before each subform is evaluated
  ;; in LispWorks
  ;; (step (+ 3 4 (* 5 6 (/ 7 8))))


  ;; apropos prints information about all symbols which match the argument

  (apropos 'string)

  ;; describe gives more informatino on a specific object

  (describe 'make-string)

  (describe 1234.56)

  ;; documentation gives a documentation string
  (documentation 'first 'function)
  (documentation 'pi 'variable)

  ;; inspect
#+end_src
** Antidebugging Tools
Consistency Checker
  - Should be used whenever a complex data structure is defined
  - Whenever an error case occurs, it should be added to the consistency checker
#+begin_src lisp :tangle ./chapter3.lisp
  ;; 3.14 Antidebugging Tools

  ;; error and cerror are used to signal an error condition


  ;; error takes a format sting and optional arguments
  ;; It stops the program upon being activated
  (defun average (numbers)
    (if (null numbers)
        (error "Average of the empty list is undefined.")
        (/ (reduce #'+ numbers)
           (length numbers))))

  ;; cerror stands for continuable erro
  ;; cerror takes two format strings
  ;; The first prints what happens if we continue
  ;; The second prints the actual error
  ;; the user can continue by typing :continue

  (defun average (numbers)
    (if (null numbers)
        (progn
          (cerror "Use 0 as the average."
                  "Average of the empty list is undefined.")
          0)
        (/ (reduce #'+ numbers)
           (length numbers))))

  ;; ecase for "exhaustive case" or "error case" will generate an error message if none of the cases are satisfied

  ;; check-type raises an error upon receiving the wrong type
  (defun sqr (x)
    "Multiply x by itself"
    (check-type x number)
    (* x x))

  ;; assert raises an error if the value passed to it is false
  ;; the user will be given the opportunity to assign a value to x
  ;; assert always returns nil
  (defun sqr (x)
    "Multiply x by itself"
    (assert (numberp x))
    (* x x))

  (defun eat-porridge (bear)
    (assert (< too-cold (temperature (bear-porridge bear)) too-hot)
            (bear (bear-porridge bear))
            "~a's porridge is just right: ~a"
            bear (hotness (bear-porridge bear))))

  (eat-porridge mama-bear)

  ;; Timing Tools

  ;; time calculates how long a function takes to execute the expression given
  (defun f (n)  (dotimes (i n) nil))

  (time (f 10000))

  ;; Compiles the function instead of just interpreting it
  (compile 'f)

  (time (f 10000))




#+end_src
** Evaluation
#+begin_src lisp :tangle ./chapter3.lisp
  ;; 3.15 Evaluation

  (+ 1 2 3 4)

  ;; funcall is used to apply a function to an individual arguments
  (funcall #'+ 1 2 3 4)

  ;; apply is used to apply a function to a list of arguments. IT can actually be given many arguments before the finargument which must be a list
  (apply #'+ '(1 2 3 4))
  (apply #'+ 1 2 '(3 4))

  ;; eval takes a single argument and evaluates it as would the repl
  (eval '(+ 1 2 3 4))
#+end_src
** Closures
#+begin_src lisp :tangle ./chapter3.lisp
  ;; 3.16 Closures

  (mapcar #'(lambda (x) (+ x x)) '(1 3 10))

  ;; Lexical closure. Variables are closed withing the function

  (defun adder (c)
    "Return a function that adds c to its argument"
    #'(lambda (x) (+ x c)))

  (mapcar (adder 3) '(1 3 10))

  (mapcar (adder 10) '(1 3 10))

  ;;  bank-account returns a closure that can be used as a representation of a bank account
  (defun bank-account (balance)
    "Open a bank account starting with the given balance"
    #'(lambda (action amount)
        (case action
          (deposit (setf balance (+ balance amount)))
          (withdraw (setf balance (- balance amount))))))

  ;; Now multiple bank accounts can be made with different closures, each with a separate value for the lexical variable balance

  (setf my-account (bank-account 200.00))

  (setf your-account (bank-account 500.00))

  (funcall my-account 'withdraw 75.00)

  (funcall your-account 'deposit 250.00)

  (funcall your-account 'deposit 100.00)

  (funcall my-account 'withdraw 25.00)
#+end_src
** Special Variables
#+begin_src lisp :tangle ./chapter3.lisp
  ;; 3.17 Special Variables

  ;; Lexical variables vs special variables

  ;; By defualt Common Lisp variables are lexical variables
  ;; Introduces with let, defun, etc...

  ;; Variables are made special with the use of defvar of defparameter

  (defvar *counter* 0)
  ;; This variable can be referred to anywhere in the program
  ;; Special variables can be bound both globally and locally

  (defun report1 ()
    (format t "Counter = ~d" *counter*))

  (report1) ;; => 0
  (let ((*counter* 100)) 
    (report1)) ;; => 100
  (report1) ;; => 0

  ;; In these two examples, var, as special variable is being set in an equivalent manner
  (setf (symbol-value 'var) value)
  (set var value)

  ;; Exercise 3.6
  ;; Given the following initialization for the lexical variable a and the special variable *b*, what will be the value of the let form?
  (setf a 'global-a) ;; Lexical binding
  (defvar *b* 'global-b) ;; Special variable

  (defun fn () *b*)

  (let ((a 'local-a)
        (*b* 'local-b))
    (list a *b* (fn) (symbol-value 'a) (symbol-value '*b*)))

  ;; => (local-a local-b local-b global-a global-b)
#+end_src
** Multiple Variables
#+begin_src lisp :tangle ./chapter3.lisp
  ;; Multiple Values

  (round 5.1) ;; Returns both the rounded integer and the remaining fraction

  ;; Take the output of second argument and bind them to the list of symbols provided
  (defun show-both (x)
    (multiple-value-bind (int rem)
        (round x)
      (format t "~f = ~d + ~f" x int rem)))

  (show-both 5.1)

  (values 1 2 3)

  ;; 'values' can be used to return no values at all, such as in describe
  (describe 'x)

  (list (describe 'x))
#+end_src
** COMMENT More about Parameters
#+begin_src lisp :tangle ./chapter3.lisp
  ;; 3.19 More about Parameters

  ;; Example program that gives practice in arithmetic

  (defun problem (x op y)
    "Ask a math problem, read a reply, and say if it is correct."
    (format t "~&How much is ~d ~a ~d?~&" x op y)
    (if (eql (read) (funcall op x y))
        (princ "Correct")
        (format t "~&Sorry, the correct answer is ~d" (funcall op x y))))

  (defun math-quiz (op range n)
    "Ask the user a series of math problems"
    (dotimes (i n)
      (problem (random range) op (random range))))

  (math-quiz '+ 100 2)

  ;; Adding default values to optional parameters
  (defun math-quiz (&optional (op '+) (range 100) (n 10))
    "Ask the user a series of math problems"
    (dotimes (i n)
      (problem (random range) op (random range))))

  ;; Equivalent calls
  (math-quiz)
  (math-quiz '+ 100 10)


  ;; Key parameters with default values
  (defun math-quiz (&key (op '+) (range 100) (n 10))
    "As the user a series of math problems"
    (dotimes (i n)
      (problem (random range) op (random range))))

  ;; Equivalent calls
  (math-quiz :n 5)
  (math-quiz :op '+ :n 5 :range 100)

  ;; keywords and lambda-list keywords
  ;; keywords are self evaluating
  :xyz ;; => :XYZ

  ;; lambda list keywords are normal symbols
  &optional

  (defun f (&xyz) (+ &xyz &xyz)) ;; & has no significance other than being suspicious

  (f 3)

  (defun f (:xyz) (+ :xyz :xyz)) ;; ERROR : keywords are constants and cannot be used as names of variables

  (defun g (&key x y) (list x y))

  (let ((keys '(:x :y :z)))
    (g (second keys) 1 (first keys) 2))

  ;; Example using find
  (find 3 '(1 2 3 4 -5 6.0))
  (find 6 '(1 2 3 4 -5 6.0))
  (find 6 '(1 2 3 4 -5 6.0) :test #'equalp)
  (find 4 '(1 2 3 4 -5 6.0) :test #'<)
  (find 5 '(1 2 3 4 -5 6.0) :key #'abs)
  ;; :test | :test-not | :key are used for matching functions
  ;; :start | :end | :from-end are used on sequence functions

  (setf (symbol-function 'find-all-if) #'remove-if-not) ;; giving and 'alias' to the function remove-if-not

  ;; Defining a find-all function
  (setf nums '(1 2 3 2 1))

  ;; (defun complement (fn)
  ;;   "If FN returns y, then (complement FN) returns (not y)"
  ;;   #'(lambda (&rest args) (not (apply fn args))))

  (defun find-all (item sequence
                   &rest keyword-args
                     &key (test #'eql) test-not &allow-other-keys)
    "Find all the elements of a sequence that match the item, according to the keywords without altering the sequence"
    (if test-not
        (apply #'remove item sequence
               :test-not (complement test-not) keyword-args)
        (apply #'remove item sequence
               :test (complement test) keyword-args)))

  (find-all 1 nums :test #'= :test #'abs)

  ;; Exercise 3.7
  ;; Why do you think the leftmost of two keys is the one that counts, rather than rightmost?
  ;; Since it is a keyword it is static

  ;; Exercise 3.8
  ;; Some versions of Kyoto Common Lisp (KCL) have a bug wherein they use the rightmost value when more thant one keyword/value pair is specifies for the same keyword. Change the definition of find-all so that it works in KCL.

  (defun find-all-KCL (item sequence
                       &rest keyword-args
                       &key (test #'eql) test-not &allow-other-keys)
    "Find all the elements of a sequence that match the item, according to the keywords without altering the sequence (KCL version)"
    (if test-not
        (apply #'remove item sequence
               :test-not (complement test-not) keyword-args)
        (apply #'remove item sequence
               :test (complement test) keyword-args)))

  (find-all-KCL 1 nums :test #'=)

  ;; Useful secondary definition of while

  (defmacro while2 (test &body body)
    "Repeat body while test is true"
    `(loop (if (not ,test) (return nil))
           . ,body))


  ;; &body is a synonym for &rest
  (setf i 0)

  (while (< i 10)
         (print (* i i))
         (setf i (* i 1)))

  (while2 (< i 10)
    (print (* i i))
    (setf i (+ i 1)))


  ;; &aux can be used to bind new local variables, as if bound with let*
  ;; try not to use

  (defun length14 (list &aux (len 0))
    (dolist (element list len)
      (incf len)))
#+end_src
** Exercises
#+begin_src lisp :tangle ./chapter3.lisp
  ;; 3.21 Exercises

  ;; Exercise 3.9
  ;; Write a version of length using the function reduce

  (defun length-reduce (xs)
    (reduce #'(lambda (x xs) (+ x 1)) xs :initial-value 0))

  (length-reduce '(100 2 3 4 5 23 2 32 23))

  ;; Exercise 3.10
  ;; Use a reference manual or 'describe to figure out what the fucntions lcm and nreconc do

  (describe #'lcm)

  ;; lcm returns the least common multiple of a list of numbers
  (lcm 8 64 12 6)

  (describe #'nreconc)
  (describe #'nreverse) ;; return a sequence of the same elements in revers order
  (describe #'nconc) ;;  concateneates the liss given as arguments

  (nreconc '(1 2 3) '(1 2)) ;; Takes two lists, reverses the first one and concatenatesa them

  ;; Exercise 3.11
  ;; There is a built-in Common Lisp function that, given a key, a value, and an association list, returns a new association list that is extended to include the key/value pair. What is the name of the function?

  ;;acons
  (setf a-list '((cat . meow) (dog . woof)))

  (assoc 'cat a-list)

  (acons 'cow 'moo a-list)

  ;; 3.12 Exercises
  ;; Write a single expression using format that will take a list of words and print them as a sentence, with the first word capitalized and a period after the last word. Consult a reference to learn new format directives.

  (defun specific-format (xs)
    (format t "~@(~{~a~^ ~}~)." xs))

  (specific-format '(cat dog horse cow))


#+end_src
* Chapter 4 : The General Problem Solver
The GPS (simplified version) can be divided into five stages of development:
   1. *Describe* the program in vague terms
   2. *Specify* the problem in algorithmic terms
   3. *Implement* the problem in a programming language
   4. *Test* the program on representative examples
   5. *Debug* and *analyze* the resulting program, and repeat the process
** 4.1 Stage 1 : Description
Solve problems using means-ends analysis, where the problem is stated in terms of what we want to happen.
Some actions require solving /preconditions/ as subproblems.
** 4.2 Stage 2 : Specification
What we are looking for from *GPS*
  - Represent a set of conditions using symbols
  - Define a list of allowable operators that will be constant over the course of a problem or series of problems. We would like to make it adjustable to be able to adapt to different project domains.
  - Represent operators and a structure composed of an action, a precondition and a list of effects. Place limits on the kinds of possible effects by saying that an effect either adds or deletes a condition from the current *state*.
  - The list of effects can be split into an add-list and a delete-list.
  - A complete problem is described to GPS in terms of a starting state, a goal state, and a set of known operators. We can see it as a function of three arguments
     #+begin_src lisp :tangle ./chapter4.lisp
       ;; Chapter 4
       ;; 4.2 Stage 2 : Specification
       ;;(GPS '(unknown poor) '(rich famous) list-of-ops)

       ;; Function used in GPS
       (defun find-all (item sequence
                   &rest keyword-args
                     &key (test #'eql) test-not &allow-other-keys)
    "Find all the elements of a sequence that match the item, according to the keywords without altering the sequence"
    (if test-not
        (apply #'remove item sequence
               :test-not (complement test-not) keyword-args)
        (apply #'remove item sequence
               :test (complement test) keyword-args)))
     #+end_src
     Starting from poor and unknown, find any means possible through the use of operators to become rich and famous.
  - If a goal is already in the current state, it is trivially achieved. Otherwise, try to find a way to apply it through the operators.
  - An operator is appropriate if the operator's effect helps to add the goal in question.
  - An operator can be applied if all the preconditions are met. Once the preconditions have been acheived, applying the operator means executing the action and updating the current state in term of the operatior's add-list and delete-list
p** 4.3 Stage 3 : Implementation
Summary of variables, data types and functions tahat make up the GPS.

| Symbol         | Use                                                 |
|                | Top-Level Function                                  |
| *GPS*            | Solve a goal from a state using a list of operators |
|                | Special Variables                                   |
| **state**        | The current state, a list of conditions             |
| **ops**          | A list of available operators                       |
|                | Data types                                          |
| *op*             | An operation with preconds, add-list and del-list   |
|                | Functions                                           |
| *achieve*        | Achieve and individual goal                         |
| *appropriate-p*  | Decide if an operator is appropriate for a goal     |
| *apply-op*       | Apply operator to current state                     |
|                | Selected Common Lisp Functions                      |
| *member*         | Test if an element is a member of a list            |
| *set-difference* | All elements in one of the sets but not the other   |
| *union*          | All elements in either of the two sets              |
| *every*          | Test if every element of a list passes a test       |
| *some*           | Test if any element of a list passes a test         |
|                | Previously defined functions                        |
| *find-all*       | A list of matching elements                         |
** 4.3 Stage 3 : Implementation
#+begin_src lisp :tangle ./chapter4.lisp
        ;; 4.3 Stage 3 : Implementation
  (defvar *state* nil "The current state: a list of conditions.")

  (defvar *ops* nil "A list of available operators.")

  (defstruct op "An operation"
    (action nil) (preconds nil) (add-list nil) (del-list nil))

  (defun GPS (*state* goals *ops*)
    "General Problem Solver: achieve all goals using *ops*."
    (if (every #'achieve goals) 'solved))

  (defun achieve (goal)
    "A goal is achieved if it already holds,
    or if there is an appropriate op for it that is applicable."
    (or (member goal *state*)
      (some #'apply-op
        (find-all goal *ops* :test #'appropriate-p))))

  (defun appropriate-p (goal op)
    "An op is appropriate to a goal if it is in its add list."
    (member goal (op-add-list op)))

  (defun apply-op (op)
    "Print a message and update *state* if op is applicable."
    (when (every #'achieve (op-preconds op))
      (print (list 'executing (op-action op)))
      (setf *state* (set-difference *state* (op-del-list op)))
      (setf *state* (union *state* (op-add-list op)))
    t))


  ;; Special variables that can be accessed from anywhere within the program

        (defvar *state* nil "The current state: a list of conditions.")
        (defvar *ops* nil "A list of available operators.")

        (defstruct op
          "An operation"
          (action nil)
          (preconds nil)
          (add-list nil)
          (del-list nil))

        ;; Defining a structure automatically defines a constructor called make-op
        ;; It also creates accessor functions op-action, op-preconds, op-add-list and op-del-list
        ;; It defines a copier copy-op, a predicate op-p and setf definitions for changing each slot

        ;;(defun make-op (&key action preconds add-list del-list)
        ;;  (vector 'op action preconds add-list del-list))

        ;; (defun op-action (op) (elt op 1))
        ;; (defun op-preconds (op) (elt op 2))
        ;; (defun op-add-list (op) (elt op 3))
        ;; (defun op-del-list (op) (elt op 4))

        ;; (defun copy-op (op (copy-seq op)))

        ;; (defun op-p (op)
        ;;   (and (vectorp op) (eq (elt op 0) 'op)))
#+end_src
** 4.4 Stage 4 : Test
Example using taking a kid to school
#+begin_src lisp :tangle ./chapter4.lisp
  ;; Stage 4 : Test

  (make-op :action 'drive-son-to-school
           :preconds '(son-at-home car-works)
           :add-list '(son-at-school)
           :del-list '(son-at-home))

  (defparameter *school-ops*
    (list
      (make-op :action 'drive-son-to-school
               :preconds '(son-at-home car-works)
               :add-list '(son-at-school)
               :del-list '(son-at-home))
      (make-op :action 'shop-installs-battery
               :preconds '(car-needs-battery shop-knows-problem shop-has-money)
               :add-list '(car-works))
      (make-op :action 'tell-shop-problem
               :preconds '(in-communication-with-shop)
               :add-list '(shop-knows-problem))
      (make-op :action 'telephone-shop
               :preconds '(know-phone-number)
               :add-list '(in-communication-with-shop))
      (make-op :action 'look-up-number
               :preconds '(have-phone-book)
               :add-list '(know-phone-number))
      (make-op :action 'give-shop-money
               :preconds '(have-money)
               :add-list '(shop-has-money)
               :del-list '(have-money))))

  (gps '(son-at-home car-needs-battery have-money have-phone-book)
       '(son-at-school)
       ,*school-ops*) ;; => Solved

  (gps '(son-at-home car-needs-battery have-money)
       '(son-at-school)
       ,*school-ops*) ;; => nil

  (gps '(son-at-home car-works)
       '(son-at-school)
       ,*school-ops*) ;; => Solved
#+end_src
** 4.5 Stage 5 : Analysis
This version of the GPS has limitations.
In the following sections, the code will be elaborated upon / changed to fit other needs.
** 4.6 Stage 6 : The Running around the Block Problem
Consider a new goal of running around the block. There is no change in location, so what do we provide for add and delete lists?
This question will touched upon later.
** 4.7 The Clobbered Sibling Problem
Not only do we have to get our child to school, but now we need to ensure we have enough money for the rest of the day.
Now, needing to purchase a battery for our car poses a problem for us. The gps reports the following as being successful, when it should not be in this case:
#+begin_src lisp :tangle ./chapter4.lisp
  ;; 4.7 The Clobbered Sibling Problem
  ;; The following situation should now have no solution, since we need to keep extra money for the day/
    (gps '(son-at-home car-needs-battery have-money have-phone-book)
         '(have-money son-at-school)
         ,*school-ops*)
#+end_src
We want to end up in a state where both son-at-school and have-money are true.
The GPS interprets this as first, achieve have-money, and then achieve son-at-school, when in reality the final state should include both.
Change the definition of achieve-all
#+begin_src lisp :tangle ./chapter4.lisp
  ;; Ensure achieve all asks for all conditions to be met at the same time
  ;; Returns true if we can acheive each goal and if the goal is a subset of the final state
  (defun achieve-all (goals)
    "Try to achieve each goal all together"
    (and (every #'achieve goals) (subsetp goals *state*)))

  (defun GPS (*state* goals *ops*)
    "General Problem Solver: achieve all goals using *ops*."
    (if (achieve-all goals) 'solved))
#+end_src
Now we impose a stronger condition on acheive-all, where the final state must include all of the conditions to be met.
** 4.8 The Leaping Before You Look Problem
Another way to solve the all conditions must be met problem is to order them in a different manner.
#+begin_src lisp :tangle ./chapter4.lisp
    ;; 4.8 The Leaping Before You Look Problem
  (gps '(son-at-home car-needs-battery have-money have-phone-book)
      '(son-at-school have-money)
      ,*school-ops*)
#+end_src
This method changes the state irreversibly before moving on to solve the next goal
** 4.9 The Recursive Subgoal Problem
Suppose we wanted to add a way to find out a phone number.
Here we must be in contact with someone in order to receive a phone number.
#+begin_src lisp :tangle ./chapter4.lisp
  ;; 4.9 The Recursive Subgoal Problem
  ;; Add operation that requires you to be in communication with someone from the shop in order to get a phone number
  (push (make-op :action 'ask-phone-number
                 :preconds '(in-communication-with-shop)
                 :add-list '(know-phone-number))
        ,*school-ops*)

  ;; This raises an error since the recursion depth is too large. 
  (gps '(son-at-home car-needs-battery have-money)
       '(son-at-school)
       ,*school-ops*)

  ;; Tracing acheive may give us insight into the problem
  (trace achieve)
#+end_src
Here there is an oscillation between in-communication-with-shop and know-phone-number.
We want to get in communication with the shop. One method is through the phone, but we don't have a phone book, so we need to get in communication to get the phone number and so on..
** 4.10 The Lack of Intermediate Information Problem
Currently, when the GPS cannot return a valid solution it only returns *nil*.
The *dbg* function prints output the same way as *format* but it will only print when we want to output debugging information.
Each call to *dbg* is accompanied by an identifier that is used to specify a class of debugging messages.
#+begin_src lisp :tangle ./chapter4.lisp
                                          ; 4.10 The Lack of Intermediate Information Problem

  ;; Sample format for dbg :identifier -> message 
  (dbg :gps "The current goal is: ~a" goal)

  ;; If debugging is turned on for the identifier :gps, then any calls to dbg with :gps will print output
  (debug :gps)
  (undebug :gps) ;; Turns off debugging

  ;; *debug-io* is the stream normally used for debugging input / output

  ;; fresh-line advances to the next line of output, unless it is already there

  (defvar *ddb-ids* nil "Identifiers used by dbg")

  (defun dbg (id format-string &rest args)
    "Print debugging info if (DEBUG ID) has been specified."
    (when (member id *dbg-ids*)
      (fresh-line *debug-io*)
      (apply #'format *debug-io* format-string args)))

  (defun debug (&rest ids)
    "Start dbg output on the given ids."
    (setf *dbg-ids* (union ids *dbg-ids*)))

  (defun undebug (&rest ids)
   "Stop dbg on the ids. With no ids, stop dbg altogether."
   (setf *dbg-ids* (if (null ids) nil
                       (set-difference *dbg-ids* ids))))

  ;; prints debug information with indentation

  (defun dbg-indent (id indent format-string &rest args)
    "Print indented debugging info if (DEBUG ID) has been specified."
    (when (member id *dbg-ids*)
      (fresh-line *debug-io*)
      (dotimes (i indent) (princ " " *debug-io*))
      (apply #'format *debug-io* format-string args)))
#+end_src
** 4.11 GPS Version 2 : A More General Problem Solver
A more rigorous GPS that attempts to deal with:
  - *running around the block* problem
  - *prerequisite clobbers sibling goal* problem
  - *leaping before you look* problem
  - *recursive subgoal* problem
    
  Glossary
| Symbol        | Use                                                   |
|               | *Top-Level Funtion*                                     |
| *GPS*           | Solve a goal from a state using a list of operators   |
|               | *Special variables*                                     |
| *ops*           | A list of available operators                         |
|               | *Data Types*                                            |
| *op*            | An operation with preconds, add-list and del-list     |
|               | *Major Function*                                        |
| *achieve-all*   | Achieve a list of goals                               |
| *achieve*       | Achieve an individual goal                            |
| *appropriate-p* | Decide if an operator is appropriate for a goal       |
| *apply-op*      | Apply operator to current state                       |
|               | *Auxilary Functions*                                    |
| *executing-p*   | Is a condition an /executing/ form?                     |
| *starts-with*   | Is the argument a list that starts with a given atom? |
| *convert-op*    | Convert an operator to use the /executing/ convention   |
| *op*            | Create an operator                                    |
| *member-equal*  | Test if an element is equal to a member of a list     |
|               | *Select Common Lisp Functions*                          |
|               |                                                       |
